---
title: Round One
---

<script lang="ts">
	import KaTeX from '$lib/components/ui/KaTeX.svelte';
	import Round1Demo from '$lib/components/demos/Round1Demo.svelte';
</script>

# Round 1: Nonce Generation and Aggregation

Round 1 in NestedMuSig2 mirrors MuSig2 in spirit but adds an explicit layered aggregation structure.

Each leaf signer runs `Sign` and samples ν = 2 random nonce scalars for each nonce coordinate, publishing commitments:

<KaTeX math={'R_{i,j} = g^{r_{i,j}}'} displayMode />

An internal node then combines child commitments coordinate-wise with `SignAgg`:

<KaTeX math={"R'_j = \\prod_i R_{i,j}"} displayMode />

These R-prime values are the internal aggregate nonces. They are pre-binding values and must be retained for Round 2 calculations.

Next comes `SignAggExt`, which is the critical defense step:

<KaTeX math={"b = H_{\\text{non}}(\\tilde{X}, R'_1, \\ldots, R'_\\nu)"} displayMode />

<KaTeX math={"R_j = (R'_j)^{b^{j-1}}"} displayMode />

The output R_j values are the external aggregate nonces that propagate upward. Without this binding transform, aggregated nonce vectors are malleable in ways that enable Wagner-style and ROS-style attacks against multi-party signing flows.

A key protocol insight from the paper is what goes into the hash. For non-root levels, binding uses `H_non` and does not include the message `m`. Only at the root does the protocol use `H_non_bar(X̃, R'_1, ..., R'_ν, m)`, which includes the message.

That separation is essential for real systems. It allows lower-level nonce exchange and aggregation to happen before the final message is known, which matches practical workflows where message construction, fee finalization, or policy checks can happen later in the signing pipeline.

Keep the distinction clear:

- Internal aggregate: pre-binding output from `SignAgg`, needed by `Sign'`.
- External aggregate: post-binding output from `SignAggExt`, forwarded to the parent.

If you only keep the external values, Round 2 cannot reconstruct the required cascade correctly for deeper signers.

Operationally, Round 1 is also where robust transcript handling matters. Each node should record which child outputs were included, in which coordinate slots, and which aggregate key was used for the binding hash. If a participant later disputes a signature failure, these Round 1 artifacts are the first place to check for mismatched inputs. In production settings, treating Round 1 as a signed transcript phase, not just a temporary cache, makes debugging and blame workflows much more reliable.

The demo below shows both layers for a small two-leaf tree.

<Round1Demo />
